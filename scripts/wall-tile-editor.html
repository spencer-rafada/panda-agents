<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Wall Auto-Tile Editor</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; padding: 20px; }
    h1 { font-size: 20px; margin-bottom: 4px; }
    .subtitle { font-size: 12px; color: #888; margin-bottom: 16px; }
    h2 { font-size: 14px; color: #6ac; margin: 20px 0 8px; }

    #load-section { margin-bottom: 16px; display: flex; align-items: center; gap: 12px; }
    #load-section input[type="file"] { font-size: 12px; }
    #load-status { font-size: 11px; color: #6a6; }

    .top-row { display: flex; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }

    #source-canvas { image-rendering: pixelated; border: 1px solid #333; display: block; }

    .piece-grid { display: grid; grid-template-columns: repeat(4, auto); gap: 8px; }
    .piece-card {
      background: #222244; border: 2px solid #333; border-radius: 6px; padding: 6px;
      text-align: center;
    }
    .piece-card canvas { display: block; margin: 0 auto 4px; image-rendering: pixelated; background: #111; }
    .piece-card .pid { font-size: 9px; color: #8ac; font-family: monospace; }
    .piece-card .pdesc { font-size: 8px; color: #666; }

    #preview-wrap { display: flex; gap: 16px; align-items: flex-start; }
    #preview-canvas { image-rendering: pixelated; border: 1px solid #333; cursor: crosshair; display: block; }
    .preview-controls { display: flex; flex-direction: column; gap: 6px; }
    .preview-controls button {
      font-size: 11px; padding: 5px 12px; background: #2a2a4a; border: 1px solid #444;
      color: #e0e0e0; border-radius: 3px; cursor: pointer; text-align: left;
    }
    .preview-controls button:hover { background: #3a3a6a; }
    .preview-hint { font-size: 10px; color: #666; margin-top: 4px; line-height: 1.5; }

    .hidden { display: none !important; }
  </style>
</head>
<body>

<h1>Wall Auto-Tile Editor</h1>
<p class="subtitle">Load walls.png (64&times;128, 4&times;4 grid). Each cell is one bitmask piece (N=1, E=2, S=4, W=8). Edit the PNG externally to change wall art.</p>

<div id="load-section">
  <input type="file" id="file-input" accept="image/png">
  <span id="load-status"></span>
</div>

<div id="content" class="hidden">
  <div class="top-row">
    <div>
      <h2>Source Image (4x)</h2>
      <canvas id="source-canvas"></canvas>
    </div>
    <div>
      <h2>All 16 Pieces (4x)</h2>
      <div class="piece-grid" id="piece-grid"></div>
    </div>
  </div>

  <h2>Live Preview</h2>
  <p style="font-size:11px; color:#888; margin-bottom:8px;">Click/drag to paint walls, right-click/drag to erase. Bitmask auto-tiling applied in real-time.</p>
  <div id="preview-wrap">
    <canvas id="preview-canvas"></canvas>
    <div class="preview-controls">
      <button onclick="presetClear()">Clear All</button>
      <button onclick="presetRoom()">Room (rect)</button>
      <button onclick="presetComplex()">Complex Layout</button>
      <div class="preview-hint">
        Click/drag = paint walls<br>
        Right-click/drag = erase<br>
        All 16 masks covered
      </div>
    </div>
  </div>
</div>

<script>
const TILE = 16;
const SPRITE_H = 32;
const GRID_COLS = 4;
const PREVIEW_ZOOM = 4;
const PIECE_ZOOM = 4;
const PV_W = 14, PV_H = 10;
const WALL_COLOR = '#3A3A5C';

const MASK_LABELS = [
  'Isolated', 'N', 'E', 'N+E', 'S', 'N+S', 'E+S', 'N+E+S',
  'W', 'N+W', 'E+W', 'N+E+W', 'S+W', 'N+S+W', 'E+S+W', 'N+E+S+W',
];

let sourceImg = null;
let pieces = []; // 16 canvas elements, indexed by mask
let grid = [];
let painting = false;
let paintValue = 1;

for (let r = 0; r < PV_H; r++) grid.push(new Array(PV_W).fill(0));

// ── Image Loading ────────────────────────────────────────
document.getElementById('file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    sourceImg = img;
    document.getElementById('load-status').textContent = `Loaded: ${img.width}×${img.height}`;
    onImageLoaded();
  };
  img.src = URL.createObjectURL(file);
});

function onImageLoaded() {
  document.getElementById('content').classList.remove('hidden');
  renderSourceImage();
  extractPieces();
  renderPieceGrid();
  presetRoom();
}

// ── Source Image ─────────────────────────────────────────
function renderSourceImage() {
  const canvas = document.getElementById('source-canvas');
  const ctx = canvas.getContext('2d');
  const z = 4;
  canvas.width = sourceImg.width * z;
  canvas.height = sourceImg.height * z;
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(sourceImg, 0, 0, canvas.width, canvas.height);

  // Grid overlay showing piece boundaries
  ctx.strokeStyle = 'rgba(100,170,200,0.4)';
  ctx.lineWidth = 1;
  for (let c = 0; c <= GRID_COLS; c++) {
    ctx.beginPath();
    ctx.moveTo(c * TILE * z + 0.5, 0);
    ctx.lineTo(c * TILE * z + 0.5, canvas.height);
    ctx.stroke();
  }
  for (let r = 0; r <= 4; r++) {
    ctx.beginPath();
    ctx.moveTo(0, r * SPRITE_H * z + 0.5);
    ctx.lineTo(canvas.width, r * SPRITE_H * z + 0.5);
    ctx.stroke();
  }

  // Mask labels
  ctx.fillStyle = '#6ac';
  ctx.font = '10px monospace';
  for (let m = 0; m < 16; m++) {
    const col = m % GRID_COLS;
    const row = Math.floor(m / GRID_COLS);
    ctx.fillText(String(m), col * TILE * z + 2, row * SPRITE_H * z + 10);
  }
}

// ── Piece Extraction ─────────────────────────────────────
function extractPieces() {
  const srcCanvas = document.createElement('canvas');
  srcCanvas.width = sourceImg.width;
  srcCanvas.height = sourceImg.height;
  const srcCtx = srcCanvas.getContext('2d');
  srcCtx.drawImage(sourceImg, 0, 0);

  pieces = [];
  for (let mask = 0; mask < 16; mask++) {
    const ox = (mask % GRID_COLS) * TILE;
    const oy = Math.floor(mask / GRID_COLS) * SPRITE_H;
    const pc = document.createElement('canvas');
    pc.width = TILE;
    pc.height = SPRITE_H;
    const ctx = pc.getContext('2d');
    ctx.drawImage(srcCanvas, ox, oy, TILE, SPRITE_H, 0, 0, TILE, SPRITE_H);
    pieces.push(pc);
  }
}

// ── Piece Grid ───────────────────────────────────────────
function renderPieceGrid() {
  const container = document.getElementById('piece-grid');
  container.innerHTML = '';
  const z = PIECE_ZOOM;

  for (let mask = 0; mask < 16; mask++) {
    const card = document.createElement('div');
    card.className = 'piece-card';

    const canvas = document.createElement('canvas');
    canvas.width = TILE * z;
    canvas.height = SPRITE_H * z;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(pieces[mask], 0, 0, canvas.width, canvas.height);

    const pid = document.createElement('div');
    pid.className = 'pid';
    pid.textContent = `mask ${mask}`;

    const pdesc = document.createElement('div');
    pdesc.className = 'pdesc';
    pdesc.textContent = MASK_LABELS[mask];

    card.appendChild(canvas);
    card.appendChild(pid);
    card.appendChild(pdesc);
    container.appendChild(card);
  }
}

// ── Live Preview ─────────────────────────────────────────
function initPreview() {
  const canvas = document.getElementById('preview-canvas');
  const s = TILE * PREVIEW_ZOOM;
  canvas.width = PV_W * s;
  canvas.height = PV_H * s;

  canvas.addEventListener('mousedown', (e) => {
    e.preventDefault();
    painting = true;
    paintValue = e.button === 2 ? 0 : -1;
    handlePreviewMouse(e);
  });
  canvas.addEventListener('mousemove', (e) => { if (painting) handlePreviewMouse(e); });
  canvas.addEventListener('mouseup', () => { painting = false; });
  canvas.addEventListener('mouseleave', () => { painting = false; });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
}

function handlePreviewMouse(e) {
  const canvas = document.getElementById('preview-canvas');
  const rect = canvas.getBoundingClientRect();
  const s = TILE * PREVIEW_ZOOM;
  const col = Math.floor((e.clientX - rect.left) / s);
  const row = Math.floor((e.clientY - rect.top) / s);
  if (col < 0 || col >= PV_W || row < 0 || row >= PV_H) return;
  if (paintValue === -1) paintValue = grid[row][col] ? 0 : 1;
  if (grid[row][col] !== paintValue) {
    grid[row][col] = paintValue;
    renderPreview();
  }
}

function renderPreview() {
  const canvas = document.getElementById('preview-canvas');
  const ctx = canvas.getContext('2d');
  const z = PREVIEW_ZOOM;
  const s = TILE * z;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.imageSmoothingEnabled = false;

  // Pass 1: base colors
  for (let r = 0; r < PV_H; r++) {
    for (let c = 0; c < PV_W; c++) {
      if (grid[r][c]) {
        ctx.fillStyle = WALL_COLOR;
      } else {
        ctx.fillStyle = (r + c) % 2 === 0 ? '#B8B4A8' : '#ACA89C';
      }
      ctx.fillRect(c * s, r * s, s, s);
    }
  }

  // Pass 2: wall sprites, row order, bottom-anchored
  for (let r = 0; r < PV_H; r++) {
    for (let c = 0; c < PV_W; c++) {
      if (!grid[r][c]) continue;
      let mask = 0;
      if (r > 0 && grid[r - 1][c]) mask |= 1;
      if (c < PV_W - 1 && grid[r][c + 1]) mask |= 2;
      if (r < PV_H - 1 && grid[r + 1][c]) mask |= 4;
      if (c > 0 && grid[r][c - 1]) mask |= 8;

      const piece = pieces[mask];
      if (!piece) continue;
      // Bottom-anchor: sprite bottom = tile bottom
      const yOff = (TILE - SPRITE_H) * z;
      ctx.drawImage(piece, 0, 0, TILE, SPRITE_H, c * s, r * s + yOff, TILE * z, SPRITE_H * z);
    }
  }

  // Grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  for (let c = 0; c <= PV_W; c++) {
    ctx.beginPath(); ctx.moveTo(c * s + 0.5, 0); ctx.lineTo(c * s + 0.5, PV_H * s); ctx.stroke();
  }
  for (let r = 0; r <= PV_H; r++) {
    ctx.beginPath(); ctx.moveTo(0, r * s + 0.5); ctx.lineTo(PV_W * s, r * s + 0.5); ctx.stroke();
  }
}

// ── Presets ──────────────────────────────────────────────
function presetClear() {
  for (let r = 0; r < PV_H; r++) for (let c = 0; c < PV_W; c++) grid[r][c] = 0;
  renderPreview();
}

function presetRoom() {
  presetClear();
  for (let c = 2; c <= 11; c++) { grid[1][c] = 1; grid[8][c] = 1; }
  for (let r = 1; r <= 8; r++) { grid[r][2] = 1; grid[r][11] = 1; }
  renderPreview();
}

function presetComplex() {
  presetClear();
  for (let c = 1; c <= 12; c++) { grid[1][c] = 1; grid[8][c] = 1; }
  for (let r = 1; r <= 8; r++) { grid[r][1] = 1; grid[r][12] = 1; }
  for (let r = 1; r <= 5; r++) grid[r][7] = 1;
  for (let c = 7; c <= 12; c++) grid[5][c] = 1;
  for (let c = 3; c <= 5; c++) grid[5][c] = 1;
  grid[5][1] = 1;
  renderPreview();
}

initPreview();
</script>
</body>
</html>
